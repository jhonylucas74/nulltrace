# Process

> File: `src/cluster/process.rs`

The `Process` is the smallest execution unit in the system. Each process wraps a **Luau thread** that runs a script preemptively.

## Structure

```rust
pub struct Process {
    pub id: u64,           // PID — generated by the OS
    thread: Thread,        // Lua thread (coroutine)
    finished: bool,        // Completion state
    duration: Instant,     // Creation timestamp (for metrics)
}
```

## Creation

```rust
pub fn new(lua: &Lua, id: u64, lua_code: &str) -> Result<Self> {
    let thread = lua.create_thread(
        lua.load(lua_code).into_function()?
    )?;
    // ...
}
```

A process is created in 3 steps:
1. **Parse**: The Lua code is compiled into bytecode with `lua.load()`
2. **Function**: The bytecode becomes a `Function` via `.into_function()`
3. **Thread**: The function is wrapped in a `Thread` (Luau coroutine)

The thread starts in the **Resumable** state — ready to execute, but still paused.

## Lifecycle (States)

The process transitions between states managed by the Luau thread:

```
                ┌──────────┐
                │ Resumable│ ← Initial state
                └────┬─────┘
                     │ thread.resume(())
                     ▼
              ┌──────────────┐
              │   Running    │ ← Executing instructions
              └──────┬───────┘
                     │
           ┌─────────┼──────────┐
           │         │          │
           ▼         ▼          ▼
    ┌──────────┐ ┌────────┐ ┌───────┐
    │Resumable │ │Finished│ │ Error │
    │ (yield)  │ │   ✓    │ │   ✗   │
    └──────────┘ └────────┘ └───────┘
         │
         └── Returns to Running on the next tick
```

| State | Meaning | Action |
|---|---|---|
| `Resumable` | Paused (yield from interrupt) | `thread.resume(())` on the next tick |
| `Running` | Currently executing | None — wait for yield or completion |
| `Finished` | Script completed successfully | `finished = true` → removed by OS |
| `Error` | Script failed (runtime error) | `finished = true` → removed by OS |

## `tick()` Method

```rust
pub fn tick(&mut self) {
    match self.thread.status() {
        ThreadStatus::Resumable => {
            self.thread.resume::<()>(());    // Resume execution
        }
        ThreadStatus::Running => { }         // Still running, wait
        ThreadStatus::Error => {
            self.finished = true;            // Error → mark as finished
        }
        ThreadStatus::Finished => {
            self.finished = true;            // Done → mark as finished
        }
    }
}
```

On each tick:
1. Check the thread status
2. If `Resumable` → call `resume()` which executes until the next **yield** (forced by the OS interrupt handler)
3. If `Finished` or `Error` → set `finished = true`

## Interaction with the Interrupt Handler

The execution time of each `resume()` is controlled by the interrupt configured in `os.rs`:

```
tick() → resume()
    │
    ├── Instruction 1: Continue
    ├── Instruction 2: Yield  ← Interrupt forces pause
    │
    └── resume() returns, control goes back to the OS
```

This ensures that **no Lua script can freeze the system** — even infinite loops are interrupted by the forced yield.
