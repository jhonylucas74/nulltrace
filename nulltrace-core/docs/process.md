# Process

> File: `src/cluster/process.rs`

The `Process` is the smallest execution unit in the system. Each process wraps a **Luau thread** that runs a script preemptively.

## Structure

```rust
pub struct Process {
    pub id: u64,                    // PID — generated by the OS (or pre-allocated for children)
    pub parent_id: Option<u64>,     // Parent process PID, if spawned as a child (e.g. via os.spawn)
    pub user_id: i32,
    pub username: String,
    pub args: Vec<String>,
    pub stdin: Arc<Mutex<VecDeque<String>>>,
    pub stdout: Arc<Mutex<String>>,
    thread: Thread,
    finished: bool,
    duration: Instant,
}
```

## Creation

```rust
pub fn new(
    lua: &Lua,
    id: u64,
    parent_id: Option<u64>,  // None for root/legacy spawns, Some(pid) for children
    user_id: i32,
    username: &str,
    lua_code: &str,
    args: Vec<String>,
) -> Result<Self>
```

Processes can be created with a pre-allocated `id` and optional `parent_id` when spawned from Lua via `os.spawn` / `os.spawn_path` (the game loop assigns the parent from the calling process's PID).

A process is created in 3 steps:
1. **Parse**: The Lua code is compiled into bytecode with `lua.load()`
2. **Function**: The bytecode becomes a `Function` via `.into_function()`
3. **Thread**: The function is wrapped in a `Thread` (Luau coroutine)

The thread starts in the **Resumable** state — ready to execute, but still paused.

## Lifecycle (States)

The process transitions between states managed by the Luau thread:

```
                ┌──────────┐
                │ Resumable│ ← Initial state
                └────┬─────┘
                     │ thread.resume(())
                     ▼
              ┌──────────────┐
              │   Running    │ ← Executing instructions
              └──────┬───────┘
                     │
           ┌─────────┼──────────┐
           │         │          │
           ▼         ▼          ▼
    ┌──────────┐ ┌────────┐ ┌───────┐
    │Resumable │ │Finished│ │ Error │
    │ (yield)  │ │   ✓    │ │   ✗   │
    └──────────┘ └────────┘ └───────┘
         │
         └── Returns to Running on the next tick
```

| State | Meaning | Action |
|---|---|---|
| `Resumable` | Paused (yield from interrupt) | `thread.resume(())` on the next tick |
| `Running` | Currently executing | None — wait for yield or completion |
| `Finished` | Script completed successfully | `finished = true` → removed by OS |
| `Error` | Script failed (runtime error) | `finished = true` → removed by OS |

## `tick()` Method

```rust
pub fn tick(&mut self) {
    match self.thread.status() {
        ThreadStatus::Resumable => {
            self.thread.resume::<()>(());    // Resume execution
        }
        ThreadStatus::Running => { }         // Still running, wait
        ThreadStatus::Error => {
            self.finished = true;            // Error → mark as finished
        }
        ThreadStatus::Finished => {
            self.finished = true;            // Done → mark as finished
        }
    }
}
```

On each tick:
1. Check the thread status
2. If `Resumable` → call `resume()` which executes until the next **yield** (forced by the OS interrupt handler)
3. If `Finished` or `Error` → set `finished = true`

## Interaction with the Interrupt Handler

The execution time of each `resume()` is controlled by the interrupt configured in `os.rs`:

```
tick() → resume()
    │
    ├── Instruction 1: Continue
    ├── Instruction 2: Yield  ← Interrupt forces pause
    │
    └── resume() returns, control goes back to the OS
```

This ensures that **no Lua script can freeze the system** — even infinite loops are interrupted by the forced yield.

### Benchmark and Interrupt Rate

The interrupt rate is controlled in `os.rs` (lines 29–34): the handler yields every **2 instructions** (`count % 2 == 0`). Each tick processes one resume per process, so you get roughly **~2 instructions per tick** per process.

A benchmark script (`BENCHMARK_LOOP` in `bench_scripts.rs`) validates this behavior: a simple loop (e.g. summing 1..1000) completes within a reasonable tick count. The test `test_program_completes_within_reasonable_ticks` runs this script and asserts that the process finishes before the limit (100,000 ticks) and that stdout contains the expected result.
